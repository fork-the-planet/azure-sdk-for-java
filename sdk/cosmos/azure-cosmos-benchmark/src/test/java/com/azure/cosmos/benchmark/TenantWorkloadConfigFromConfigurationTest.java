// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.cosmos.benchmark;

import com.beust.jcommander.Parameter;
import org.testng.annotations.Test;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Ensures that {@link TenantWorkloadConfig#fromConfiguration(Configuration)} maps all
 * workload-relevant fields from {@link Configuration}. When a new {@code @Parameter} field
 * is added to {@code Configuration}, this test will fail unless the field is either:
 * <ul>
 *   <li>mapped in {@code fromConfiguration()}, or</li>
 *   <li>added to the {@code EXCLUDED_FIELDS} allowlist with a justification.</li>
 * </ul>
 */
public class TenantWorkloadConfigFromConfigurationTest {

    /**
     * Configuration fields intentionally NOT copied to TenantWorkloadConfig.
     * Each entry has a comment explaining why it is excluded.
     */
    private static final Set<String> EXCLUDED_FIELDS = new HashSet<>(Arrays.asList(
        // Lifecycle/orchestrator-level fields (handled in BenchmarkConfig, not per-tenant)
        "tenantsFile",
        "cycles",
        "settleTimeMs",
        "suppressCleanup",
        "gcBetweenCycles",
        "enableJvmStats",
        "printingInterval",
        "numberOfAutoGeneratedKeysForReadBenchmark",

        // Result upload fields (handled in BenchmarkConfig)
        "serviceEndpointForRunResultsUploadAccount",
        "masterKeyForRunResultsUploadAccount",
        "resultUploadDatabase",
        "resultUploadContainer",
        "testVariationName",
        "branchName",
        "commitId",

        // JVM-global system properties (handled in BenchmarkConfig)
        "isPartitionLevelCircuitBreakerEnabled",
        "isPerPartitionAutomaticFailoverRequired",
        "minConnectionPoolSizePerEndpoint",

        // Azure Monitor config (handled at orchestrator level)
        "azureMonitorMeterRegistry",

        // Reporting output (handled in BenchmarkConfig)
        "reportingDirectory",
        "graphiteEndpoint",
        "graphiteEndpointPort",
        "accountNameInGraphiteReporter",

        // Sync-only flag (multi-tenant benchmark is async-only)
        "useSync",

        // LinkedIn-specific CTL fields (not applicable to multi-tenant benchmark)
        "numberOfCollectionForCtl",
        "readWriteQueryReadManyPct",
        "bulkloadBatchSize",
        "testScenario",
        "encryptedStringFieldCount",
        "encryptedLongFieldCount",
        "encryptedDoubleFieldCount",
        "encryptionEnabled",
        "environment",

        // CLI help flag
        "help",

        // Internal/infra fields
        "metricsRegistry",

        // Diagnostics threshold (mapped via separate pointLatencyThresholdMs/nonPointLatencyThresholdMs)
        "diagnosticsThresholdDuration"
    ));

    @Test(groups = {"unit"})
    public void fromConfigurationShouldMapAllWorkloadFields() {
        // Collect all @Parameter field names from Configuration
        Set<String> configFieldNames = new HashSet<>();
        for (Field field : Configuration.class.getDeclaredFields()) {
            if (field.isAnnotationPresent(Parameter.class)) {
                configFieldNames.add(field.getName());
            }
        }

        // Get the source of fromConfiguration to find which fields are referenced
        // We check that every Configuration @Parameter field is either mapped or excluded
        Set<String> unmappedFields = new HashSet<>();
        for (String fieldName : configFieldNames) {
            if (!EXCLUDED_FIELDS.contains(fieldName) && !isMappedInFromConfiguration(fieldName)) {
                unmappedFields.add(fieldName);
            }
        }

        assertThat(unmappedFields)
            .as("Configuration @Parameter fields not mapped in TenantWorkloadConfig.fromConfiguration() "
                + "and not in EXCLUDED_FIELDS allowlist. Either add mapping in fromConfiguration() "
                + "or add to EXCLUDED_FIELDS with justification.")
            .isEmpty();
    }

    /**
     * Checks whether a Configuration field is referenced in fromConfiguration() by verifying
     * that a corresponding getter is called (heuristic: a getter for the field exists in
     * Configuration and TenantWorkloadConfig has a field with a matching name).
     */
    private boolean isMappedInFromConfiguration(String configFieldName) {
        // Check if TenantWorkloadConfig has a field with the same or similar name
        Set<String> tenantFieldNames = Arrays.stream(TenantWorkloadConfig.class.getDeclaredFields())
            .map(Field::getName)
            .collect(Collectors.toSet());

        // Direct name match
        if (tenantFieldNames.contains(configFieldName)) {
            return true;
        }

        // Check common naming variations between Configuration and TenantWorkloadConfig
        Set<String> knownMappings = new HashSet<>(Arrays.asList(
            "collectionId",              // mapped to containerId
            "operationType",             // mapped via cfg.getOperationType().name() -> operation
            "serviceEndpoint",           // direct match
            "masterKey",                 // direct match
            "pointLatencyThresholdMs",   // mapped to pointOperationLatencyThresholdMs
            "nonPointLatencyThresholdMs", // mapped to nonPointOperationLatencyThresholdMs
            "defaultLog4jLoggerEnabled"  // mapped to isDefaultLog4jLoggerEnabled
        ));

        return knownMappings.contains(configFieldName);
    }
}
